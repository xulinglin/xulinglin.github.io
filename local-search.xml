<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java 二分查找插入排序</title>
    <link href="/blogs/2021/06/04/java/java-binary-search/"/>
    <url>/blogs/2021/06/04/java/java-binary-search/</url>
    
    <content type="html"><![CDATA[<p>二分（折半）插入排序是一种在直接插入排序算法上进行小改动的排序算法。其与直接排序算法最大的区别在于查找插入位置时使用的是二分查找的方式，在速度上有一定提升。</p><h2 id="1-原理解析"><a href="#1-原理解析" class="headerlink" title="1. 原理解析"></a>1. 原理解析</h2><p class="note note-secondary">总共有N个元素，当插入第i个元素时，对前面的 0~i-1 个元素进行折半，先跟他们中间的那个元素比，如果小，那么再对前半折半 否则对后半进行折半，知道左<右，然后再把第i个元素前一位于目标位置之间的所有元素后移，再把第i个元素放在目标位置上。</p><p>关说原理可能大家不是很理解，下面我们就用一个列子来详细说明一下：<br>例如：我们当前数组为 <span class="label label-warning">[4 5 7 10 29 30] 11</span><br>已知当前 0到第N-1个 都是按顺序排序，现在对第N个11找对应位置。</p><h3 id="1-1-第一趟"><a href="#1-1-第一趟" class="headerlink" title="1.1. 第一趟"></a>1.1. 第一趟</h3><ul>    <li>[<span class="label label-info">4</span> 5 7 <span class="label label-warning">10</span> 29 <span class="label label-danger">30</span>] 11</li>    <li><span class="label label-info">L</span> <span class="label label-warning">M</span> <span class="label label-danger">R</span></li>    <li>11比中间M大</li></ul><h3 id="1-2-那么接下来第二趟为："><a href="#1-2-那么接下来第二趟为：" class="headerlink" title="1.2. 那么接下来第二趟为："></a>1.2. 那么接下来第二趟为：</h3><ul>    <li>[<span class="label label-info">4</span> 5 7 <span class="label label-warning">10</span> 29 <span class="label label-danger">30</span>] 11</li>    <li><span class="label label-info">L</span> <span class="label label-warning">M</span> <span class="label label-danger">R</span></li>    <li>11比中间M大</li>    <li>那么11的位置就在M+1这个</li></ul><p>注意，我们这里的第0到第N-1已经是按照要求排好序的</p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySort</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;            <span class="hljs-keyword">int</span> ia[] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>&#125;;            sort(ia);        System.out.println(Arrays.toString(ia));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">( <span class="hljs-keyword">int</span>[] array)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; array.length; i++) &#123;            <span class="hljs-keyword">int</span> temp = array[i];            <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>, high = i - <span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> mid = -<span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span> (low &lt;= high) &#123;                mid = low + (high - low) / <span class="hljs-number">2</span>;                <span class="hljs-keyword">if</span> (array[mid] &gt; temp) &#123;                    high = mid - <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 元素相同时，也插入在后面的位置</span>                    low = mid + <span class="hljs-number">1</span>;                &#125;            &#125;            System.out.println(<span class="hljs-string">&quot;i:&quot;</span>+i+<span class="hljs-string">&quot; &quot;</span>+Arrays.toString(array));            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= low; j--) &#123;                array[j + <span class="hljs-number">1</span>] = array[j];            &#125;            array[low] = temp;            System.out.println(<span class="hljs-string">&quot;i:&quot;</span>+i+<span class="hljs-string">&quot; &quot;</span>+Arrays.toString(array));        &#125;    &#125;&#125;</code></pre></div><ul>    <li>当前 i 为 8 值为 3</li>    <li>计算第一次: 从0开始 到 high - 1 的位置 0 7,7/2=3 i 的 3 为 5 此时判断 5 是大于还是小于 小于 查找 3 前面索引值,大于查找 3 后面的索引值</li>    <li>每次计算 low + (high - low) / 2 开始位置 + （高度-开始 / 2）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Volatile 关键字</title>
    <link href="/blogs/2021/06/04/java/Volatile/"/>
    <url>/blogs/2021/06/04/java/Volatile/</url>
    
    <content type="html"><![CDATA[<p>Java 语言中的 <span class="label label-primary">volatile</span> 关键字可以被看作是一种程度较轻的 <span class="label label-primary">synchronized</span> ;跟 <span class="label label-primary">synchronized</span> 相比 <span class="label label-primary">volatile</span> 使用起来简单方便,编码较少。但是也仅仅只有 <span class="label label-primary">synchronized</span> 的部分功能。通过下文,让我们更加理解其意义。合理使用 <span class="label label-primary">volatile</span>  关键字,从而减少不必要的系统开销。</p><ul>    <li>锁提供了两种主要特性： <span class="label label-danger">互斥（mutual exclusion）</span>和 <span class="label label-info">可见性（visibility）</span>。互斥即一次只允许一个线程持有某个特定的锁，因此可使用该特性实现对共享数据的协调访问协议，这样，一次就只有一个线程能够使用该共享数据。</li>    <li>可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的。</li></ul><p>如果没有同步机制提供的这种可见性保证，线程看到的共享变量可能是修改前的值或不一致的值，这将引发许多严重问题。</p><h2 id="1-volatile特性"><a href="#1-volatile特性" class="headerlink" title="1. volatile特性"></a>1. volatile特性</h2><ul>    <li>保证可见性</li>    <li>禁止指令重排</li></ul><h3 id="1-1-可见性"><a href="#1-1-可见性" class="headerlink" title="1.1. 可见性"></a>1.1. 可见性</h3><p>内存可见性：（Memory Visibility）是指当某个线程正在使用对象状态而另一个线程在同时修改该状态，需要确保当一个线程修改了对象状态后，其他线程能够立即看到发生的状态变化。<br>举个例子：</p><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileTest</span></span>&#123;<span class="hljs-comment">//    static volatile boolean flag = true;</span>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>) &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">while</span> (flag) &#123;                &#125;                System.out.println(<span class="hljs-string">&quot;end......&quot;</span>);            &#125;        &#125;.start();        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">1000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        flag = <span class="hljs-keyword">false</span>;        System.out.println(<span class="hljs-string">&quot;end main......&quot;</span>);    &#125;&#125;</code></pre></div><p>执行结果:<br><img src="/essay/Volatile/img_1.png"></p><p>运行上面代码，会发现程序无法终止。</p><ul>    <li>线程t1的run()方法中有个循环，通过 flag 来控制循环是否结束，主线程中休眠了1秒，将 flag 置为false，按说此时线程t1会检测到 flag 为false，打印“end main......”，为何结果不是这样</li>    <li>运行上面的代码我们可以判断，t1中看到的 flag 一直为true，主线程将 flag 置为false之后，t1线程中并没有看到，所以一直死循环。</li>    <li>那么t1中为什么看不到被主线程修改之后的flag？</li></ul><p class="note note-info">首先要先了解一下java内存模型（JMM），Java线程之间的通信由Java内存模型（称为JMM）控制， <span class="label label-warning">JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。</span> 本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p>Java内存模型的抽象示意图如下：<p><img src="/essay/Volatile/img.png"></p><h4 id="1-1-1-根据上图说说上面代码-执行过程。线程A-t1-跟线程B-main-的交互："><a href="#1-1-1-根据上图说说上面代码-执行过程。线程A-t1-跟线程B-main-的交互：" class="headerlink" title="1.1.1. 根据上图说说上面代码,执行过程。线程A(t1)跟线程B(main)的交互："></a>1.1.1. 根据上图说说上面代码,执行过程。线程A(t1)跟线程B(main)的交互：</h4><ul>    <li>首先，线程A将去 主内存 读取 共享变量 到 本地变量 中,此时线程A读取到 flag 为 true。</li>    <li>然后，线程B也有自己 本地变量,将 flag 修改为 false 刷新到 主内存 中。</li></ul><p class="note note-secondary">JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。对JMM了解之后，我们再看看文章开头的问题，线程t1中为何看不到被主线程修改为false的 flag 的值，有两种可能:</p><ul>    <li>线程B(main)修改了 flag 之后，未将其刷新到主内存，所以线程A(t1)看不到</li>    <li>线程B(main)将 flag 刷新到了主内存，但是线程A(t1)一直读取的是自己工作内存中 flag 的值，没有去主内存中获取 flag 最新的值</li></ul><p class="note note-success">对于上面2种情况，java帮我们提供了这样的方法，使用 volatile 修饰共享变量，就可以达到上面的效果，被 volatile 修改的变量有以下特点：</p><ul>    <li>线程中读取的时候，每次读取都会去主内存中读取共享变量最新的值，然后将其复制到工作内存</li>    <li>线程中修改了工作内存中变量的副本，修改之后会立即刷新到主内存</li></ul><h3 id="1-2-禁止指令重排"><a href="#1-2-禁止指令重排" class="headerlink" title="1.2. 禁止指令重排"></a>1.2. 禁止指令重排</h3><span class="label label-primary">volatile</span> 实现禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象<p class="note note-primary">先了解一个概念，内存屏障（Memory Barrier） 又称内存栅栏，是一个CPU指令，它的作用有两个：</p><ul>    <li>证某些变量的内存可见性</li>    <li>保证特定操作的执行顺序</li></ul><p class="note note-light">由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排，也就是说通过插入内存屏障，就能禁止在内存屏障前后的指令执行重排优化。内存屏障另外一个作用就是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。</p><h2 id="2-JMM内存屏障插入策略"><a href="#2-JMM内存屏障插入策略" class="headerlink" title="2. JMM内存屏障插入策略"></a>2. JMM内存屏障插入策略</h2><ul>    <li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li>    <li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li>    <li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li>    <li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>volatile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch 集群的工作原理</title>
    <link href="/blogs/2021/06/04/es/ElasticSearch1.0/"/>
    <url>/blogs/2021/06/04/es/ElasticSearch1.0/</url>
    
    <content type="html"><![CDATA[<p>说说 Elasticsearch 存储原理,相信有不少人都会关心数据存储在ES中的存储容量。</p><h2 id="1-读写架构"><a href="#1-读写架构" class="headerlink" title="1. 读写架构"></a>1. 读写架构</h2><p><img src="/essay/ElasticSearch1.0/img.png"></p><h2 id="2-写入过程"><a href="#2-写入过程" class="headerlink" title="2. 写入过程"></a>2. 写入过程</h2><ul>    <li>客户端选择一个node发送请求过去,当前node会去找对应的主分片(primary shard) 的 node 如果主分片不在当前节点上,就将请求转发给主分片的 node。</li>    <li>主分片node在接收到请求document,进行数据写入。然后将数据同步到replica node。(注意如果你没有指定 doc id,document会自动给你分配一个全局唯一的doc id)</li>    <li>当主分片(primary shard) 跟 replica node 写完时就响应客户端,代表本次写入成功</li></ul><h2 id="3-查询过程"><a href="#3-查询过程" class="headerlink" title="3. 查询过程"></a>3. 查询过程</h2><ul>    <li>客户端发送请求到node节点上,当前 node将判断 document 存储哪些 node 上并且进行请求转发给当前 node 。(这里会使用round-robin随机轮询算法,进行负载均衡)</li>    <li>node接收到document 后给doc id 进行 hash去对应的 shard 上进行查询,然后给 document 返回给客户端</li></ul><h2 id="4-原理"><a href="#4-原理" class="headerlink" title="4. 原理"></a>4. 原理</h2><ul>    <li>数据写入内存 buffer,同时写入一份到translog日志文件。在buffer中的数据是无法搜索的</li>    <li>默认是每隔一秒,将 buffer 中数据生成一个新的segment file 写进去,写入前会先进入os cache。如果buffer中有数据就进行refresh操作。数据这时就可以查询了</li>    <li>buffer中的数据每次刷新到os cache就会被清空。translog就不会而且会变得越来越大。当translog达到一定长度的时候，就会触发commit操作</li>    <li>commit操作就是将buffer中现有数据refresh到os cache中去,清空buffer。然后将os cache中目前所有的数据都fsync到磁盘文件中。在清空translog日志文件</li>    <li>删除操作：将document 标识为 dalete,并没有进行物理删除</li>    <li>修改操作：将document 标识为 dalete,并没有进行物理删除,然后在添加一条数据</li>    <li>默认是1秒钟buffer每次refresh一次,就会产生一个segment file,segment file会越来越多</li>    <li>当segment file到一定程度时会进行合并将多个segment file 合并为一个 segment file</li>    <li>同时将标识为deleted的doc给物理删除掉,然后将新的segment file写入磁盘。在更新segment file的标识</li></ul><h2 id="5-数据丢失"><a href="#5-数据丢失" class="headerlink" title="5. 数据丢失"></a>5. 数据丢失</h2><p class="note note-danger">translog 每秒5会进行持久化刷新到磁盘。translog 之前是在 os cache的（缓冲区里面）。如果这时宕机了最多丢失5秒数据。也有不丢失数据的方法,每次强制将translog刷新到磁盘,然后在算成功写入。这样就会大大降低吞吐量。</p>]]></content>
    
    
    
    <tags>
      
      <tag>es</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell脚本部署jar包</title>
    <link href="/blogs/2021/06/04/linux/Linux-jar/"/>
    <url>/blogs/2021/06/04/linux/Linux-jar/</url>
    
    <content type="html"><![CDATA[<p class="note note-info">Linux 下部署 jar的脚本,以及一些采用的设置参数。</p><h2 id="1-目录包"><a href="#1-目录包" class="headerlink" title="1. 目录包"></a>1. 目录包</h2><div class="hljs code-wrapper"><pre><code class="hljs Python"><span class="hljs-string">&quot;脚本&quot;</span>   <span class="hljs-string">&quot;配置&quot;</span>   <span class="hljs-string">&quot;包&quot;</span>   <span class="hljs-string">&quot;日志&quot;</span> <span class="hljs-built_in">bin</span>     conf      lib     logo<span class="hljs-string">&quot;给启动权限&quot;</span>chmod a+x startup.sh <span class="hljs-string">&quot;查看端口是否可用&quot;</span>netstat -anp|grep <span class="hljs-number">3306</span><span class="hljs-string">&quot;看日志&quot;</span>tail -fn <span class="hljs-number">200</span> **.log</code></pre></div><h2 id="2-startup-sh-启动脚本"><a href="#2-startup-sh-启动脚本" class="headerlink" title="2. startup.sh(启动脚本)"></a>2. startup.sh(启动脚本)</h2><div class="hljs code-wrapper"><pre><code class="hljs Bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment">## confirm app dir.</span>DIR=$(<span class="hljs-built_in">cd</span> `dirname <span class="hljs-variable">$0</span>`; <span class="hljs-built_in">cd</span> ..; <span class="hljs-built_in">pwd</span>)<span class="hljs-comment">## confirm conf dir.</span>CONF=<span class="hljs-variable">$DIR</span>/conf<span class="hljs-comment">## confirm lib.</span>JAR=<span class="hljs-variable">$DIR</span>/lib/spax-ec-pay-service-1.0.0.jar<span class="hljs-comment">## profile</span>PROFILE=<span class="hljs-built_in">test</span><span class="hljs-comment">## jvm配置参数</span>JVM=<span class="hljs-string">&quot;-Xms1024m -Xmx1024m -Xmn512m -Xss256k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=256m -XX:-UseAdaptiveSizePolicy -XX:TargetSurvivorRatio=90 -XX:MaxTenuringThreshold=15 -XX:+UseConcMarkSweepGC -server&quot;</span><span class="hljs-comment">## SpringBoot 2.0 版本以上 -Dspring.config.additional-location 加载外部配置文件,以下的用 -Dspring.config.location </span>nohup java <span class="hljs-variable">$&#123;JVM&#125;</span> -jar <span class="hljs-variable">$JAR</span> -Dspring.config.additional-location=<span class="hljs-variable">$CONF</span>/ -Dspring.profiles.active=<span class="hljs-variable">$PROFILE</span> &gt; /dev/null 2&gt;&amp;1 &amp;</code></pre></div><h2 id="3-shutdown-sh-关闭脚本"><a href="#3-shutdown-sh-关闭脚本" class="headerlink" title="3. shutdown.sh(关闭脚本)"></a>3. shutdown.sh(关闭脚本)</h2><div class="hljs code-wrapper"><pre><code class="hljs Bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment">## indexOf function.</span><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">indexOf</span></span>()&#123;  arr=<span class="hljs-variable">$1</span>  <span class="hljs-built_in">local</span> index=1  <span class="hljs-built_in">local</span> e  <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;arr[*]&#125;</span>; <span class="hljs-keyword">do</span>    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$2</span> = <span class="hljs-string">&quot;<span class="hljs-variable">$e</span>&quot;</span> ]; <span class="hljs-keyword">then</span>      <span class="hljs-built_in">return</span> <span class="hljs-variable">$index</span>    <span class="hljs-keyword">else</span>      (( index= index+1 ))    <span class="hljs-keyword">fi</span>  <span class="hljs-keyword">done</span>  <span class="hljs-built_in">return</span> 0&#125;JPS=`/opt/java/jdk1.8/bin/jps`attr=(<span class="hljs-variable">$JPS</span>)indexOf <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;attr[*]&#125;</span>&quot;</span> **名称.jarret=$?<span class="hljs-keyword">if</span> [ <span class="hljs-variable">$ret</span> != 0 ]; <span class="hljs-keyword">then</span>  (( ret=<span class="hljs-variable">$ret</span>-2 ))  process=<span class="hljs-variable">$&#123;attr[$ret]&#125;</span>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;kill process &#x27;</span><span class="hljs-variable">$process</span>  <span class="hljs-built_in">kill</span> -9 <span class="hljs-variable">$process</span><span class="hljs-keyword">fi</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;finish stop!&quot;</span></code></pre></div><h2 id="4-PS-查询-pid"><a href="#4-PS-查询-pid" class="headerlink" title="4. PS 查询 pid"></a>4. PS 查询 pid</h2><div class="hljs code-wrapper"><pre><code class="hljs Bash"><span class="hljs-meta">#!/bin/bash</span>JARFILE=<span class="hljs-string">&#x27;名称.jar&#x27;</span><span class="hljs-built_in">echo</span> <span class="hljs-variable">$JARFILE</span>ID=`ps -ef | grep <span class="hljs-string">&quot;<span class="hljs-variable">$JARFILE</span>&quot;</span> | grep -v <span class="hljs-string">&quot;grep&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>`<span class="hljs-built_in">echo</span> <span class="hljs-variable">$ID</span><span class="hljs-keyword">for</span> id <span class="hljs-keyword">in</span> <span class="hljs-variable">$ID</span><span class="hljs-keyword">do</span><span class="hljs-built_in">kill</span> -9 <span class="hljs-variable">$id</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;kill process <span class="hljs-variable">$id</span>&quot;</span><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;finish stop!&quot;</span></code></pre></div><h2 id="5-restart-sh-重新启动"><a href="#5-restart-sh-重新启动" class="headerlink" title="5. restart.sh(重新启动)"></a>5. restart.sh(重新启动)</h2><div class="hljs code-wrapper"><pre><code class="hljs Bash"><span class="hljs-meta">#!/bin/bash</span>sh shutdown.shsh startup.sh</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>jar部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解 synchronized 原理</title>
    <link href="/blogs/2021/06/04/java/synchronized1.0/"/>
    <url>/blogs/2021/06/04/java/synchronized1.0/</url>
    
    <content type="html"><![CDATA[<span class="label label-primary">Synchronized</span> 是一种JVM锁,大部分人都只是会使用 <span class="label label-primary">Synchronized</span>  关键子,在方法上加入 <span class="label label-primary">Synchronized</span>  就能对共享变量进行线程安全的使用,确没有了解 <span class="label label-primary">Synchronized</span>  大部分真正含义,如,<span class="label label-primary">Synchronized</span>  锁的级别,锁的范围(使用不同的对象,锁的范围不同)。希望下文对各位有所帮助。<h2 id="1-Synchronized使用"><a href="#1-Synchronized使用" class="headerlink" title="1. Synchronized使用"></a>1. Synchronized使用</h2><h3 id="1-1-修饰实例方法"><a href="#1-1-修饰实例方法" class="headerlink" title="1.1. 修饰实例方法"></a>1.1. 修饰实例方法</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedTest</span> </span>&#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">monitor</span><span class="hljs-params">()</span></span>&#123;        i++;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">monitor1</span><span class="hljs-params">()</span></span>&#123;        i++;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SynchronizedTest test = <span class="hljs-keyword">new</span> SynchronizedTest();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;             test.monitor();         &#125;).start();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;             test.monitor1();         &#125;).start();    &#125;&#125;</code></pre></div><p>上面代码我们在 <span class="label label-primary">SynchronizedTest</span> 类中有 <span class="label label-primary">monitor()</span> 以及 <span class="label label-primary">monitor1()</span> 两个方法.<br>分别都加了一个 <span class="label label-primary">synchronized</span> 两个方法都操作了一个 int 为 i 的共享变量,看<span class="label label-primary">main</span>方法比如有两个线程, 线程A访问 <span class="label label-primary">monitor()</span> 线程B访问 <span class="label label-primary">monitor1()</span> 都是用的 test对象进行调用的,此时我们的 锁的范围 当前 test对象。</p><p class="note note-info">修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。同一Class类不同的实例对象锁的范围,已对象为单位</p><h3 id="1-2-静态对象"><a href="#1-2-静态对象" class="headerlink" title="1.2. 静态对象"></a>1.2. 静态对象</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedTest</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">monitor</span><span class="hljs-params">()</span></span>&#123;        i++;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">monitor1</span><span class="hljs-params">()</span></span>&#123;        i++;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SynchronizedTest test = <span class="hljs-keyword">new</span> SynchronizedTest();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            test.monitor();        &#125;).start();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            SynchronizedTest.monitor1();        &#125;).start();    &#125;&#125;</code></pre></div><p>上面代码我们在 <span class="label label-primary">SynchronizedTest</span> 类中有 <span class="label label-primary">monitor()</span> 以及 <span class="label label-primary">monitor1()</span> 两个方法.<br>分别都加了一个 <span class="label label-primary">synchronized</span> 两个方法都操作了一个 static int 为 i 的共享变量,看main方法比如有两个线程, 线程A访问 <span class="label label-primary">test.monitor()</span>,线程B访问 <span class="label label-primary">SynchronizedTest.monitor1()</span>,main运行肯定是线程不安全的,两个方法都加了 <span class="label label-primary">synchronized</span> 但是锁的对象不同,一个是实例对象,一个是静态对象</p><p class="note note-info">修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。静态变量为全局唯一的,所有对象在锁静态对象时间单位为Class。不同的对象使用静态变量为锁时,所有对象使用的是同一吧锁</p><h3 id="1-3-代码块"><a href="#1-3-代码块" class="headerlink" title="1.3. 代码块"></a>1.3. 代码块</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedTest</span> </span>&#123;    Object lock = <span class="hljs-keyword">new</span> Object();    <span class="hljs-keyword">static</span> Object lockStatic = <span class="hljs-keyword">new</span> Object();    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">monitor</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">synchronized</span> (lock) &#123;            i++;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">monitor1</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">synchronized</span> (lockStatic) &#123;            i++;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">monitor2</span><span class="hljs-params">()</span></span>&#123;        i++;    &#125;&#125;</code></pre></div><p class="note note-info">修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。代码块加锁需要用实例对象或者静态对象,看自己定义锁的范围标准。</p><h3 id="1-4-如上代码查看同步方法的class文件"><a href="#1-4-如上代码查看同步方法的class文件" class="headerlink" title="1.4. 如上代码查看同步方法的class文件"></a>1.4. 如上代码查看同步方法的class文件</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">monitor</span><span class="hljs-params">()</span></span>;    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: aload_0         <span class="hljs-number">1</span>: getfield      #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field lock:Ljava/lang/Object;</span>         <span class="hljs-number">4</span>: dup         <span class="hljs-number">5</span>: astore_1         <span class="hljs-number">6</span>: monitorenter         <span class="hljs-number">7</span>: getstatic     #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Field i:I</span>        <span class="hljs-number">10</span>: iconst_1        <span class="hljs-number">11</span>: iadd        <span class="hljs-number">12</span>: putstatic     #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Field i:I</span>        <span class="hljs-number">15</span>: aload_1        <span class="hljs-number">16</span>: monitorexit        <span class="hljs-number">17</span>: goto          <span class="hljs-number">25</span>        <span class="hljs-number">20</span>: astore_2        <span class="hljs-number">21</span>: aload_1        <span class="hljs-number">22</span>: monitorexit        <span class="hljs-number">23</span>: aload_2        <span class="hljs-number">24</span>: athrow        <span class="hljs-number">25</span>: <span class="hljs-keyword">return</span>        ...</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">monitor2</span><span class="hljs-params">()</span></span>;descriptor: ()Vflags: ACC_PUBLIC, ACC_SYNCHRONIZEDCode:  stack=<span class="hljs-number">0</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>     <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span>  LineNumberTable:    line <span class="hljs-number">18</span>: <span class="hljs-number">0</span>  LocalVariableTable:    Start  Length  Slot  Name   Signature        <span class="hljs-number">0</span>       <span class="hljs-number">1</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">this</span>   Lcom/springstudy/simplespring/SynchronizedTest;</code></pre></div><ul>    <li><span class="label label-primary">monitor()</span> 方法,同步代码块的起始位置插入了 <span class="label label-primary">monitorenter</span> 指令，在同步代码块结束的位置插入了 <span class="label label-primary">monitorexit指令</span>。(JVM需要保证每一个monitorenter都有一个monitorexit与之相对应，但每个monitorexit不一定都有一个monitorenter)</li>    <li><span class="label label-primary">monitor2()</span> 方法,翻译成普通的方法调用和返回指令，只是在其常量池中多了 <span class="label label-primary">ACC_SYNCHRONIZED</span> 标示符</li></ul><p class="note note-info">JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放 monitor。在方法执行期间，其他任何线程都无法再获得同一个 monitor 对象。其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。monitorenter 和 monitorexit 指令是通过 monitor 对象实现的。</p><h3 id="1-5-monitorenter"><a href="#1-5-monitorenter" class="headerlink" title="1.5. monitorenter"></a>1.5. monitorenter</h3><p class="note note-info">每个对象都有一个监视器锁(monitor)与之对应。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p><ul>    <li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者.</li>    <li>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</li>    <li>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权.</li></ul><h3 id="1-6-monitorexit"><a href="#1-6-monitorexit" class="headerlink" title="1.6. monitorexit"></a>1.6. monitorexit</h3><p class="note note-info">执行monitorexit的线程必须是objectref所对应的monitor的所有者。<br>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。<br>其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权。</p><p>通过这两个指令我们应该能很清楚的看出<span class="label label-primary">synchronized</span>的实现原理，<span class="label label-primary">synchronized</span>的语义底层是通过一个<span class="label label-primary">monitor</span>的对象来完成，其实wait/notify等方法也依赖于<span class="label label-primary">monitor</span>对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出<span class="label label-primary">java.lang.IllegalMonitorStateException</span>的异常的原因。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jvm 配置及优化</title>
    <link href="/blogs/2021/06/04/jvm/jvm3.0/"/>
    <url>/blogs/2021/06/04/jvm/jvm3.0/</url>
    
    <content type="html"><![CDATA[<p>Java 虚拟机有自己完善的硬件架构, 如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM 屏蔽了与具体操作系统平台相关的信息，使得 Java 程序只需生成在 Java 虚拟机上运行的目标代码 (字节码), 就可以在多种平台上不加修改地运行。<br>JVM是JAVA世界的核心，了解它有助于我们更好调试，调优和开发程序。</p><h2 id="1-命令"><a href="#1-命令" class="headerlink" title="1. 命令"></a>1. 命令</h2><h3 id="1-1-查看-java-pid项目"><a href="#1-1-查看-java-pid项目" class="headerlink" title="1.1. 查看 java pid项目"></a>1.1. 查看 java pid项目</h3><div class="hljs code-wrapper"><pre><code class="hljs Java">jps</code></pre></div><h3 id="1-2-收集内存使用基本情况统计"><a href="#1-2-收集内存使用基本情况统计" class="headerlink" title="1.2. 收集内存使用基本情况统计"></a>1.2. 收集内存使用基本情况统计</h3><div class="hljs code-wrapper"><pre><code class="hljs Java">jmap -heap [pid] &gt; [路径]</code></pre></div><p class="note note-info">如：jmap -heap 16155 > /opt/jmapheap jmapheap 是文件名称</p><h3 id="1-3-查看GC使用情况"><a href="#1-3-查看GC使用情况" class="headerlink" title="1.3. 查看GC使用情况"></a>1.3. 查看GC使用情况</h3><div class="hljs code-wrapper"><pre><code class="hljs Java">jstat -gcutil [pid] [毫秒]</code></pre></div><p class="note note-info">如：jstat -gcutil 16155 1000</p><h3 id="1-4-获取dump文件"><a href="#1-4-获取dump文件" class="headerlink" title="1.4. 获取dump文件"></a>1.4. 获取dump文件</h3><div class="hljs code-wrapper"><pre><code class="hljs Java">jmap -dump:file=[文件名称] [pid]</code></pre></div><p class="note note-info">如：jmap -dump:file=test.dump 16155, jmap在获取dump文件时候会停止应用注意,也可以hprof结尾</p><h2 id="2-常用配置"><a href="#2-常用配置" class="headerlink" title="2. 常用配置"></a>2. 常用配置</h2><h3 id="2-1-jvm-参数配置"><a href="#2-1-jvm-参数配置" class="headerlink" title="2.1. jvm 参数配置"></a>2.1. jvm 参数配置</h3><div class="hljs code-wrapper"><pre><code class="hljs Python">-Xms1024m -Xmx1024m -Xmn512m -Xss256k -XX:NewRatio=<span class="hljs-number">4</span> -XX:SurvivorRatio=<span class="hljs-number">4</span> -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=256m -XX:TargetSurvivorRatio=<span class="hljs-number">90</span>-XX:+HeapDumpOnOutOfMemoryError-XX:HeapDumpPath=$DIR -XX:MaxTenuringThreshold=<span class="hljs-number">15</span> -XX:+UseConcMarkSweepGC -server</code></pre></div><ul>    <li><span class="label label-primary">-Xmx</span> 设置最大堆大小</li>    <li><span class="label label-primary">-Xms</span> 设置最小堆大小,最小堆跟最大堆,最好保持一致以免 动荡的 java 堆</li>    <li><span class="label label-primary">-Xmn</span> 设置年轻代大小</li>    <li><span class="label label-primary">-Xss</span> 设置每个线程的堆栈大小。</li>    <li><span class="label label-primary">-XX:NewRatio</span> 设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5</li>    <li><span class="label label-primary">-XX:SurvivorRatio</span> 设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6</li>    <li><span class="label label-primary">-XX:MetaspaceSize</span> 设置元数据大小。</li>    <li><span class="label label-primary">-XX:MaxMetaspaceSize</span> 设置最大元数据大小</li>    <li><span class="label label-primary">-XX:TargetSurvivorRatio</span> 在新生代的对象不一定要满足存活年龄达到MaxTenuringThreshold才能去老年代，当Survivor空间中相同年龄所有对象大小总和大于[Desired survivor size]时，年龄大于或等于该年龄的对象直接进入老年代。</li>    <li><span class="label label-primary">-XX:MaxTenuringThreshold</span> 设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</li>    <li><span class="label label-primary">-XX:SurvivorRatio:</span> 指定NewGeneration中EdenSpace与一个SurvivorSpace的堆size比例,</li>    <li><span class="label label-primary">XX:SurvivorRatio=8</span> ，那么在总共NewGeneration为10m的情况下，EdenSpace为8m</li>    <li><span class="label label-primary">-XX:+UseConcMarkSweepGC:</span> 指定在OldGeneration使用CMSGC，GCThread和APPThread并行(在init-mark和remark时PauseAPPThread)。apppause时间较短，适合交互性强的系统。</li></ul><h3 id="2-2-看看GC次数"><a href="#2-2-看看GC次数" class="headerlink" title="2.2. 看看GC次数"></a>2.2. 看看GC次数</h3><div class="hljs code-wrapper"><pre><code class="hljs Python">[root@localhost <span class="hljs-built_in">bin</span>]<span class="hljs-comment"># jstat -gcutil 4031 1000</span> S0     S1     E      O      M     CCS    YGC      YGCT    FGC    FGCT     GCT   <span class="hljs-number">0.00</span>  <span class="hljs-number">56.81</span>  <span class="hljs-number">72.20</span>   <span class="hljs-number">2.77</span>  <span class="hljs-number">96.20</span>  <span class="hljs-number">94.35</span>     <span class="hljs-number">19</span>    <span class="hljs-number">0.768</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.768</span><span class="hljs-number">0.00</span>  <span class="hljs-number">56.81</span>  <span class="hljs-number">72.20</span>   <span class="hljs-number">2.77</span>  <span class="hljs-number">96.20</span>  <span class="hljs-number">94.35</span>     <span class="hljs-number">19</span>    <span class="hljs-number">0.768</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.768</span><span class="hljs-number">0.00</span>  <span class="hljs-number">56.81</span>  <span class="hljs-number">72.45</span>   <span class="hljs-number">2.77</span>  <span class="hljs-number">96.20</span>  <span class="hljs-number">94.35</span>     <span class="hljs-number">19</span>    <span class="hljs-number">0.768</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.768</span><span class="hljs-number">0.00</span>  <span class="hljs-number">56.81</span>  <span class="hljs-number">72.45</span>   <span class="hljs-number">2.77</span>  <span class="hljs-number">96.20</span>  <span class="hljs-number">94.35</span>     <span class="hljs-number">19</span>    <span class="hljs-number">0.768</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.768</span><span class="hljs-number">0.00</span>  <span class="hljs-number">56.81</span>  <span class="hljs-number">72.45</span>   <span class="hljs-number">2.77</span>  <span class="hljs-number">96.20</span>  <span class="hljs-number">94.35</span>     <span class="hljs-number">19</span>    <span class="hljs-number">0.768</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.768</span><span class="hljs-number">0.00</span>  <span class="hljs-number">56.81</span>  <span class="hljs-number">72.45</span>   <span class="hljs-number">2.77</span>  <span class="hljs-number">96.20</span>  <span class="hljs-number">94.35</span>     <span class="hljs-number">19</span>    <span class="hljs-number">0.768</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.768</span><span class="hljs-number">0.00</span>  <span class="hljs-number">56.81</span>  <span class="hljs-number">72.45</span>   <span class="hljs-number">2.77</span>  <span class="hljs-number">96.20</span>  <span class="hljs-number">94.35</span>     <span class="hljs-number">19</span>    <span class="hljs-number">0.768</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.768</span><span class="hljs-number">0.00</span>  <span class="hljs-number">56.81</span>  <span class="hljs-number">72.45</span>   <span class="hljs-number">2.77</span>  <span class="hljs-number">96.20</span>  <span class="hljs-number">94.35</span>     <span class="hljs-number">19</span>    <span class="hljs-number">0.768</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.768</span><span class="hljs-number">0.00</span>  <span class="hljs-number">56.81</span>  <span class="hljs-number">72.45</span>   <span class="hljs-number">2.77</span>  <span class="hljs-number">96.20</span>  <span class="hljs-number">94.35</span>     <span class="hljs-number">19</span>    <span class="hljs-number">0.768</span>     <span class="hljs-number">0</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.768</span></code></pre></div><ul>    <li><span class="label label-primary">S0</span> ：幸存1区当前使用比例</li>    <li><span class="label label-primary">S1</span> ：幸存2区当前使用比例</li>    <li><span class="label label-primary">E</span> ：伊甸园区使用比例</li>    <li><span class="label label-primary">O</span> ：老年代使用比例</li>    <li><span class="label label-primary">M</span> ：元数据区使用比例</li>    <li><span class="label label-primary">CCS</span> ：压缩使用比例</li>    <li><span class="label label-primary">YGCT</span> ：年轻代垃圾回收消耗总时间</li>    <li><span class="label label-primary">FGC</span> ：老年代垃圾回收次数</li>    <li><span class="label label-primary">FGCT</span> ：老年代垃圾回收消耗时间</li>    <li><span class="label label-primary">GCT</span> ：垃圾回收消耗总时间</li></ul><h2 id="3-heap堆的配置"><a href="#3-heap堆的配置" class="headerlink" title="3. heap堆的配置"></a>3. heap堆的配置</h2><div class="hljs code-wrapper"><pre><code class="hljs Python">[root@localhost <span class="hljs-built_in">bin</span>]<span class="hljs-comment"># jmap -heap 4031</span>Attaching to process ID <span class="hljs-number">4031</span>, please wait...Debugger attached successfully.Server compiler detected.JVM version <span class="hljs-keyword">is</span> <span class="hljs-number">25.231</span>-b11using parallel threads <span class="hljs-keyword">in</span> the new generation.using thread-local <span class="hljs-built_in">object</span> allocation.Concurrent Mark-Sweep GCHeap Configuration:   //最小空闲比率   MinHeapFreeRatio         = <span class="hljs-number">40</span>   //最大空闲比率   MaxHeapFreeRatio         = <span class="hljs-number">70</span>   //堆的最大大小   MaxHeapSize              = <span class="hljs-number">1073741824</span> (<span class="hljs-number">1024.0</span>MB)   //新生代的默认大小   NewSize                  = <span class="hljs-number">536870912</span> (<span class="hljs-number">512.0</span>MB)   //新生代的最大大小   MaxNewSize               = <span class="hljs-number">536870912</span> (<span class="hljs-number">512.0</span>MB)   //老年代的默认大小   OldSize                  = <span class="hljs-number">536870912</span> (<span class="hljs-number">512.0</span>MB)   NewRatio                 = <span class="hljs-number">4</span>   SurvivorRatio            = <span class="hljs-number">4</span>   //元空间的默认大小   MetaspaceSize            = <span class="hljs-number">268435456</span> (<span class="hljs-number">256.0</span>MB)   //类指针压缩空间的默认大小   CompressedClassSpaceSize = <span class="hljs-number">260046848</span> (<span class="hljs-number">248.0</span>MB)   //元空间的最大大小   MaxMetaspaceSize         = <span class="hljs-number">268435456</span> (<span class="hljs-number">256.0</span>MB)   //使用G1垃圾收集器的时候   G1HeapRegionSize         = <span class="hljs-number">0</span> (<span class="hljs-number">0.0</span>MB)Heap Usage:New Generation (Eden + <span class="hljs-number">1</span> Survivor Space):   capacity = <span class="hljs-number">447414272</span> (<span class="hljs-number">426.6875</span>MB)   used     = <span class="hljs-number">317350352</span> (<span class="hljs-number">302.6488800048828</span>MB)   free     = <span class="hljs-number">130063920</span> (<span class="hljs-number">124.03861999511719</span>MB)   <span class="hljs-number">70.9298678786894</span>% usedEden Space: //Eden区域分配情况   capacity = <span class="hljs-number">357957632</span> (<span class="hljs-number">341.375</span>MB)   used     = <span class="hljs-number">266528528</span> (<span class="hljs-number">254.18141174316406</span>MB)   free     = <span class="hljs-number">91429104</span> (<span class="hljs-number">87.19358825683594</span>MB)   <span class="hljs-number">74.45812134548929</span>% usedFrom Space: //其中一个Survivor区域分配情况   capacity = <span class="hljs-number">89456640</span> (<span class="hljs-number">85.3125</span>MB)   used     = <span class="hljs-number">50821824</span> (<span class="hljs-number">48.46746826171875</span>MB)   free     = <span class="hljs-number">38634816</span> (<span class="hljs-number">36.84503173828125</span>MB)   <span class="hljs-number">56.81168440934066</span>% usedTo Space: //另一个Survivor区域分配情况   capacity = <span class="hljs-number">89456640</span> (<span class="hljs-number">85.3125</span>MB)   used     = <span class="hljs-number">0</span> (<span class="hljs-number">0.0</span>MB)   free     = <span class="hljs-number">89456640</span> (<span class="hljs-number">85.3125</span>MB)   <span class="hljs-number">0.0</span>% usedconcurrent mark-sweep generation:   capacity = <span class="hljs-number">536870912</span> (<span class="hljs-number">512.0</span>MB)   used     = <span class="hljs-number">14854688</span> (<span class="hljs-number">14.166534423828125</span>MB)   free     = <span class="hljs-number">522016224</span> (<span class="hljs-number">497.8334655761719</span>MB)   <span class="hljs-number">2.7669012546539307</span>% used<span class="hljs-number">36932</span> interned Strings occupying <span class="hljs-number">4449232</span> <span class="hljs-built_in">bytes</span>.</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java HashMap原理以及常见的面试题</title>
    <link href="/blogs/2021/06/04/java/HashMap/"/>
    <url>/blogs/2021/06/04/java/HashMap/</url>
    
    <content type="html"><![CDATA[<p class="note note-info">叙述 <span class="label label-primary">HashMap</span> 原理这里以代码为例,本文还回分析一些HashMap在面试中遇到的一些问题以及解答。</p><h2 id="1-先了解几点重要知识"><a href="#1-先了解几点重要知识" class="headerlink" title="1. 先了解几点重要知识"></a>1. 先了解几点重要知识</h2><h3 id="1-1-HashMap的组成"><a href="#1-1-HashMap的组成" class="headerlink" title="1.1. HashMap的组成"></a>1.1. HashMap的组成</h3><ul>    <li>JDK1.7 数组+列表（Entry）分散存储在一个数组。</li>    <li>JDK1.8 数组+列表+红黑树,（Entry）分散存储在一个数组。JDK1.8中在 <span class="label label-primary">HashMap</span> 中引入了红黑树的概念。</li></ul><h3 id="1-2-扩容因子：0-75"><a href="#1-2-扩容因子：0-75" class="headerlink" title="1.2. 扩容因子：0.75"></a>1.2. 扩容因子：0.75</h3><ul>    <li>加载因子是表示Hash表中元素的填满的程度。加载因子越大,填满的元素越多,空间利用率越高，但冲突的机会加大了。</li>    <li>反之,加载因子越小,填满的元素越少,冲突的机会减小,但空间浪费多了。</li>    <li>因此,必须在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷。</li>    <li><span class="label label-primary">HashMap</span>负载因子为 0.75 (百分之75) 是空间和时间成本的一种折中。</li></ul><h3 id="1-3-初始容量：2的幂次方"><a href="#1-3-初始容量：2的幂次方" class="headerlink" title="1.3. 初始容量：2的幂次方"></a>1.3. 初始容量：2的幂次方</h3><p>在初始化时 <span class="label label-primary">HashMap</span> 会计算当前容量是否为2的幂次方,如果不是将补足。</p><p class="note note-info">如：new HashMap<>(10) 假设我们初始化数组容量为10,在初始化会计算为2的幂次方也就是16。</p>如下代码：<div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;        n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;        n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;        n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;        n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;        n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;        <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;&#125;</code></pre></div><h3 id="1-4-Hash槽定位"><a href="#1-4-Hash槽定位" class="headerlink" title="1.4. Hash槽定位"></a>1.4. Hash槽定位</h3><p>样例代码：</p><div class="hljs code-wrapper"><pre><code class="hljs Java">HashMap map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();map.put(<span class="hljs-number">20</span>,<span class="hljs-string">&quot;定位Hash槽&quot;</span>);</code></pre></div><p>以上给 <span class="label label-primary">HashMap</span> 中添加了一个key为20的元素：</p><p>1.在put元素时会将当前key计算hash值,通过现有的key计算确认hashCode为20,下面看看 Hash槽是如何定位到数组里的。<br>2.用Hash值定位数组:</p><ul>    <li>hashCode 20转为二进制位为10100,(默认的长度容量为16,是下面代码 n 的值）length-1=15 = 01111 (n - 1),用2进制算法的与进行计算 10100 & 01111 = 00100 = 4</li>    <li>说说与符号计算,二进制为 10100 跟 01111 相比 都为1的输出 1 所以计算后为 00100 = 4 最后N位刚好就是十进制的取余运算的结果 20 % 16 = 4</li>    <li>为什么要用二进制算,不用 % 求模算,因为二进制算的速度比求模快10倍</li></ul><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)   tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);</code></pre></div><h3 id="1-5-源码解析-get：获取元素"><a href="#1-5-源码解析-get：获取元素" class="headerlink" title="1.5. 源码解析 get：获取元素"></a>1.5. 源码解析 get：获取元素</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-string">&#x27;以下操作牵扯到数组,链表以及红黑树本文章不做讲解&#x27;</span><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;        Node e; <span class="hljs-string">&#x27;一.查询到的元素&#x27;</span>        <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;&#125;<span class="hljs-string">&#x27;二.获取Node方法&#x27;</span><span class="hljs-string">&#x27;1).hash 为key的hash值;&#x27;</span><span class="hljs-string">&#x27;2).key 为键;&#x27;</span><span class="hljs-string">&#x27;3).Node[] tab;为数组&#x27;</span><span class="hljs-string">&#x27;4).Node first;(链表或红黑树)&#x27;</span><span class="hljs-string">&#x27;5).Node e;子节点&#x27;</span><span class="hljs-string">&#x27;5).int n 数组长度&#x27;</span><span class="hljs-string">&#x27;5).K k 存储在节点中的Key元素&#x27;</span><span class="hljs-function"><span class="hljs-keyword">final</span> Node <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key)</span> </span>&#123;    Node[] tab; Node first, e; <span class="hljs-keyword">int</span> n; K k;    <span class="hljs-string">&#x27;将成员变量tab赋给局部变量tab,并且当前数组的长度大于0,并且定位到hash槽中的节点不为空,将数组里的节点获取出来&#x27;</span>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-string">&#x27;//first = tab[(n - 1) &amp; hash])定位hash槽获取元素&#x27;</span>        <span class="hljs-string">&#x27;判断根节点的hash以及key是否完全相等。链表以及红黑树的根节点的操作复杂度为0(1)&#x27;</span>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span>            ((k = first.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))            <span class="hljs-string">&#x27;相等就返回元素&#x27;</span>            <span class="hljs-keyword">return</span> first;           <span class="hljs-string">&#x27;判断子节点不为空&#x27;</span>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-string">&#x27;判断是否为红黑树&#x27;</span>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)                <span class="hljs-string">&#x27;如果是转换为红黑树,调用getTreeNode查找元素,并返回&#x27;</span>                <span class="hljs-keyword">return</span> ((TreeNode)first).getTreeNode(hash, key);            <span class="hljs-string">&#x27;不为红黑树,就是链表循环遍历查找元素&#x27;</span>            <span class="hljs-keyword">do</span> &#123;                <span class="hljs-string">&#x27;如链表中hash以及key是否完全相等&#x27;</span>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))                    <span class="hljs-string">&#x27;相等就返回元素&#x27;</span>                    <span class="hljs-keyword">return</span> e;            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><h3 id="1-6-源码解析-put：添加元素"><a href="#1-6-源码解析-put：添加元素" class="headerlink" title="1.6. 源码解析 put：添加元素"></a>1.6. 源码解析 put：添加元素</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-string">&#x27;1).Node[] tab;为数组&#x27;</span><span class="hljs-string">&#x27;2).Node p;为节点(链表或红黑树)&#x27;</span><span class="hljs-string">&#x27;5).int n 数组长度&#x27;</span><span class="hljs-string">&#x27;5).i 为定位hash槽的下标(数组下标)&#x27;</span><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;    Node[] tab; Node p; <span class="hljs-keyword">int</span> n, i;    <span class="hljs-string">&#x27;判断当前数组是否为空&#x27;</span>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)        <span class="hljs-string">&#x27;等于空就调整大小&#x27;</span>        n = (tab = resize()).length;    <span class="hljs-string">&#x27;定位hash槽获取元素(Node 节点)&#x27;</span>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)        <span class="hljs-string">&#x27;为空创建一个新的链表&#x27;</span>        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-string">&#x27;判断根节点的hash以及key是否完全相等。链表以及红黑树的根节点的操作复杂度为0(1)&#x27;</span>        Node e; K k;        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;            <span class="hljs-string">&#x27;如果根节点key相等&#x27;</span>            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))            <span class="hljs-string">&#x27;相等就替换&#x27;</span>            e = p;        <span class="hljs-string">&#x27;判断是否为红黑树&#x27;</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)            <span class="hljs-string">&#x27;是就转换到红黑树中进行添加元素操作&#x27;</span>            e = ((TreeNode)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);        <span class="hljs-string">&#x27;根节点不相等进行下面代码&#x27;</span>        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-string">&#x27;循环操作(无条件操作,直到成功时停止循环)&#x27;</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;                <span class="hljs-string">&#x27;判断子节点是否为空&#x27;</span>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-string">&#x27;为空就创建一个新的节点,并且赋值给当前节点&#x27;</span>                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);                    <span class="hljs-string">&#x27;判断循环次数是否大于等于 8 - 1 的长度&#x27;</span>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span>                        <span class="hljs-string">&#x27;是就将当前链表转换为红黑树继续操作&#x27;</span>                        treeifyBin(tab, hash);                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-string">&#x27;子节点不为空,判断子节点的hash以及key相等,是就停止循环。e 为HashMap里有的值,需要将value替换&#x27;</span>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))                    <span class="hljs-keyword">break</span>;                <span class="hljs-string">&#x27;将节点值赋值给局部变量,进行下一次修改&#x27;</span>                p = e;            &#125;        &#125;        <span class="hljs-string">&#x27;如果e元素存在声明,之前HashMap节点中有这个key根value,value的值需要&#x27;</span>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span>            V oldValue = e.value;            <span class="hljs-string">&#x27;替换值 !onlyIfAbsent 为 true&#x27;</span>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)                e.value = value;            <span class="hljs-string">&#x27;将当前节点移动到链表最后&#x27;</span>            afterNodeAccess(e);            <span class="hljs-keyword">return</span> oldValue;        &#125;    &#125;    <span class="hljs-string">&#x27;如果代码进入这说明,是新添加了一个元素&#x27;</span>    ++modCount;    <span class="hljs-string">&#x27;判断当前tab数组是否要扩容&#x27;</span>    <span class="hljs-keyword">if</span> (++size &gt; threshold)        <span class="hljs-string">&#x27;调整数组大小&#x27;</span>        resize();    afterNodeInsertion(evict);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><h3 id="1-7-源码解析-resize-扩容"><a href="#1-7-源码解析-resize-扩容" class="headerlink" title="1.7. 源码解析 resize: 扩容"></a>1.7. 源码解析 resize: 扩容</h3><ul>    <li>当容量大于 0.75 负载因子进行扩。 即默认情况下数组长度是16*0.75=12时，触发扩容操作。</li>    <li>创建一个原来的2倍数组,将原数组值复制进去,这里需要重新计算位置,我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)</li></ul><p><img src="/essay/HashMap/img.png"></p><p class="note note-info">元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="/essay/HashMap/img_1.png"></p><p class="note note-info">因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p><p><img src="/essay/HashMap/img_2.png"></p><h2 id="2-HashMap-面试题"><a href="#2-HashMap-面试题" class="headerlink" title="2. HashMap 面试题"></a>2. HashMap 面试题</h2><h3 id="2-1-HashMap1-7跟1-8的HashMap的区别"><a href="#2-1-HashMap1-7跟1-8的HashMap的区别" class="headerlink" title="2.1. HashMap1.7跟1.8的HashMap的区别"></a>2.1. HashMap1.7跟1.8的HashMap的区别</h3><ul>    <li><span class="label label-primary">HashMap1.7</span> 是由 数组+链接组成</li>    <li><span class="label label-primary">HashMap1.8</span> 是由 数组+链接+红黑树组成</li></ul><h3 id="2-2-HashMap1-8-为什么要引入红黑树-有那些好处"><a href="#2-2-HashMap1-8-为什么要引入红黑树-有那些好处" class="headerlink" title="2.2. HashMap1.8 为什么要引入红黑树,有那些好处"></a>2.2. HashMap1.8 为什么要引入红黑树,有那些好处</h3><ul>    <li>首先红黑树是一个绝对 平衡二叉树 ,操作级别在<span class="label label-primary">O(logN)</span>,链接的插入节点操作是<span class="label label-primary">O(1)</span>级别,查询为<span class="label label-primary">O(n)</span>级别的。</li>    <li><span class="label label-primary">HashMap</span>的<span class="label label-primary">Hash</span>冲突如果链表来存储,如果链接很长,需要从头节点查询到尾节点查询开销太大,查询速度慢。</li>    <li>引用红黑树是,当链表长度为8的时候会将链表转换为红黑树进行存储,红黑树的查询是通过左右子树查询的。(这里不做过多的解释了,有兴趣可以去看看 红黑树 或 平衡二叉树)</li></ul><h3 id="2-3-HashMap1-7用的是链表头节点插入-HashMap1-8是用尾节点插入的有什么区别-会发生什么问题"><a href="#2-3-HashMap1-7用的是链表头节点插入-HashMap1-8是用尾节点插入的有什么区别-会发生什么问题" class="headerlink" title="2.3. HashMap1.7用的是链表头节点插入,HashMap1.8是用尾节点插入的有什么区别,会发生什么问题"></a>2.3. HashMap1.7用的是链表头节点插入,HashMap1.8是用尾节点插入的有什么区别,会发生什么问题</h3><ul>    <li><span class="label label-primary">1.7</span> 头节点插入数据,主要是考虑热点数据的原因, 而 <span class="label label-primary">1.8</span> 引入了红黑树不需要考虑热点数据。</li>    <li><span class="label label-primary">1.7</span> 头节点插入,在<span class="label label-primary">resize()</span>扩容会使链表形成倒序,(形成倒序之后会发生死循环,当多线程处理的时候，此时如果存在a->b->c链表，当我们rehash以后，有可能变为b->a，然而其他的线程处理完之后，结果可能会造成b->a->b，造成loop成环。一旦寻找数据会造成死循环。)</li>    <li><span class="label label-primary">1.8</span> 为了解决 <span class="label label-primary">1.7</span> 中的一些问题,采用了尾部插入的方式,源码中使用了一个高位来识别之前的数据和插入的新数据，保持了之前的顺序，解决了<span class="label label-primary">1.7</span>中可能造成成环的问题。具体的实现是扩容只有最高位会多出一个1，如果之前的数据一旦e & oldCapacity = 0，表明是原来的数据，保持就好，如果是为1，表明是即将插入的新数据，此时保持插入高位，这样就避免了成环的问题。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java OOM定位处理</title>
    <link href="/blogs/2021/06/04/java/OOM1.0/"/>
    <url>/blogs/2021/06/04/java/OOM1.0/</url>
    
    <content type="html"><![CDATA[<p class="note note-info">本文针对处理 <span class="label label-primary">OOM</span> 的定位问题,查询以及解决问题。</p><h2 id="1-常见的几种方式"><a href="#1-常见的几种方式" class="headerlink" title="1. 常见的几种方式"></a>1. 常见的几种方式</h2><h3 id="1-1-GC-overhead-limit-exceeded"><a href="#1-1-GC-overhead-limit-exceeded" class="headerlink" title="1.1. GC overhead limit exceeded"></a>1.1. GC overhead limit exceeded</h3><div class="hljs code-wrapper"><pre><code class="hljs Java">Java.lang.OutOfMemeoryError:GC overhead limit exceeded</code></pre></div><p class="note note-danger">即程序在垃圾回收上花费了98%的时间，却收集不回2%的空间，通常这样的异常伴随着CPU的冲高。不同的垃圾回收器 OOM 的异常错误不同。</p><h3 id="1-2-StackOverflowError-栈溢出"><a href="#1-2-StackOverflowError-栈溢出" class="headerlink" title="1.2. StackOverflowError (栈溢出)"></a>1.2. StackOverflowError (栈溢出)</h3><div class="hljs code-wrapper"><pre><code class="hljs Java">java.lang.StackOverflowError</code></pre></div><h3 id="1-3-PermGen-space-元空间耗尽"><a href="#1-3-PermGen-space-元空间耗尽" class="headerlink" title="1.3. PermGen space (元空间耗尽)"></a>1.3. PermGen space (元空间耗尽)</h3><div class="hljs code-wrapper"><pre><code class="hljs Java">Java.lang.OutOfMemoryError: PermGen space</code></pre></div><h3 id="1-4-Java-heap-space-堆内存溢出"><a href="#1-4-Java-heap-space-堆内存溢出" class="headerlink" title="1.4. Java heap space (堆内存溢出)"></a>1.4. Java heap space (堆内存溢出)</h3><div class="hljs code-wrapper"><pre><code class="hljs Java">java.lang.OutOfMemoryError: Java heap space</code></pre></div><h3 id="1-5-Direct-buffer-memory-用来-nio-，但是-direct-buffer-不够"><a href="#1-5-Direct-buffer-memory-用来-nio-，但是-direct-buffer-不够" class="headerlink" title="1.5. Direct buffer memory (用来 nio ，但是 direct buffer 不够)"></a>1.5. Direct buffer memory (用来 nio ，但是 direct buffer 不够)</h3><div class="hljs code-wrapper"><pre><code class="hljs Java">java.lang.OutOfMemoryError: Direct buffer memory</code></pre></div><h2 id="2-OOM-定位"><a href="#2-OOM-定位" class="headerlink" title="2. OOM 定位"></a>2. OOM 定位</h2><h3 id="2-1-GC-overhead-limit-exceeded"><a href="#2-1-GC-overhead-limit-exceeded" class="headerlink" title="2.1. GC overhead limit exceeded"></a>2.1. GC overhead limit exceeded</h3><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * jvm参数配置</span><span class="hljs-comment"> * -Xms40m  最小堆</span><span class="hljs-comment"> * -Xmx40m  最大堆</span><span class="hljs-comment"> * -XX:+HeapDumpOnOutOfMemoryError 堆异常输出dump文件</span><span class="hljs-comment"> * -XX:HeapDumpPath=D:\360MoveData\Desktop 输出dump文件路径</span><span class="hljs-comment"> */</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XulinglinApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(XulinglinApplication.class, args);    &#125;    <span class="hljs-comment">//初始化60w数据到HashMap中</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> HashMap <span class="hljs-title">hashMapdump</span><span class="hljs-params">()</span></span>&#123;        HashMap hashMap = <span class="hljs-keyword">new</span> HashMap();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">600000</span> ; i++) &#123;            hashMap.put(i,i);        &#125;        <span class="hljs-keyword">return</span> hashMap;    &#125;&#125;</code></pre></div><h3 id="2-2-异常错误log日志"><a href="#2-2-异常错误log日志" class="headerlink" title="2.2. 异常错误log日志"></a>2.2. 异常错误log日志</h3><div class="hljs code-wrapper"><pre><code class="hljs Java">Caused by: java.lang.OutOfMemoryError: GC overhead limit exceeded    at java.util.HashMap.newNode(HashMap.java:<span class="hljs-number">1734</span>) ~[na:<span class="hljs-number">1.8</span><span class="hljs-number">.0_91</span>]    at java.util.HashMap.putVal(HashMap.java:<span class="hljs-number">630</span>) ~[na:<span class="hljs-number">1.8</span><span class="hljs-number">.0_91</span>]    at java.util.HashMap.put(HashMap.java:<span class="hljs-number">611</span>) ~[na:<span class="hljs-number">1.8</span><span class="hljs-number">.0_91</span>]    at com.xulinglin.XulinglinApplication.hashMapdump(XulinglinApplication.java:<span class="hljs-number">20</span>) [classes/:na]    at com.xulinglin.XulinglinApplication$$EnhancerBySpringCGLIB$$a8f9ee58.CGLIB$hashMapdump$<span class="hljs-number">0</span>() ~[classes/:na]    at com.xulinglin.XulinglinApplication$$EnhancerBySpringCGLIB$$a8f9ee58$$FastClassBySpringCGLIB$$9b30d517.invoke() ~[classes/:na]</code></pre></div><p class="note note-primary">文件名称:java_pid73956.hprof,hprof 可以格式让我们更好的利用第三方插件来定位问题。比如使用 Eclipse IDE</p><h3 id="2-3-Hprof-拖入-Eclipse-IDE分析"><a href="#2-3-Hprof-拖入-Eclipse-IDE分析" class="headerlink" title="2.3. Hprof 拖入 Eclipse IDE分析"></a>2.3. Hprof 拖入 Eclipse IDE分析</h3><p><img src="/essay/OOM1.0/img.png"><br><img src="/essay/OOM1.0/img_1.png"></p><p class="note note-primary">通过上图,可以基本确定导致内存溢出的代码位置。</p><p><img src="/essay/OOM1.0/img_2.png"><br><img src="/essay/OOM1.0/img_3.png"></p><p class="note note-success">通过 IDE 分析dump文件,查看栈的信息,查看导致内存溢出的对象或容器里具体存储什么信息来定位具体原因</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>OOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 虚拟机 Jvm 内存模型</title>
    <link href="/blogs/2021/06/04/jvm/jvm2.0/"/>
    <url>/blogs/2021/06/04/jvm/jvm2.0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-内存模型"><a href="#1-内存模型" class="headerlink" title="1. 内存模型"></a>1. 内存模型</h2><p><img src="/essay/jvm2.0/img.png"></p><h2 id="2-主要存放对象实例"><a href="#2-主要存放对象实例" class="headerlink" title="2. 主要存放对象实例"></a>2. 主要存放对象实例</h2><p><img src="/essay/jvm2.0/img_1.png"></p><h2 id="3-程序计数器"><a href="#3-程序计数器" class="headerlink" title="3. 程序计数器"></a>3. 程序计数器</h2><p>程序计数器记录当前线程执行程序的位置，改变计数器的值来确定执行的下一条指令，比如循环、分支、方法跳转、异常处理，线程恢复都是依赖程序计数器来完成。</p><h2 id="4-方法区"><a href="#4-方法区" class="headerlink" title="4. 方法区"></a>4. 方法区</h2><p>主要存储一些：加载类的信息 、常量、静态变量、即时编译器编译后的代码等元数据信息。</p><p>重要区域为常量池: 常量池又分为静态常量池跟运行时常量池。</p><p>静态常量池：我们也叫class常量池,存放一些字符串、数字还有一些类以及方法。</p><p>运行时常量池：是虚拟机 (JVM) 在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中。载入到内存中,也就是说将class常量池中的内容存放到运行时常量池中。</p><p>class常量池是固定的,但运行时常量池在运行时动态添入。</p><p>比如String的intern<br><img src="/essay/jvm2.0/img_2.png"></p><h2 id="5-本地方法栈"><a href="#5-本地方法栈" class="headerlink" title="5. 本地方法栈"></a>5. 本地方法栈</h2><p>本地方法栈、为虚拟机调用本地方法服务（native）。</p><h2 id="6-虚拟机栈"><a href="#6-虚拟机栈" class="headerlink" title="6. 虚拟机栈"></a>6. 虚拟机栈</h2><p>java中每创建一个方法都会有栈帧,栈帧会存在虚拟机栈中。用压栈出栈的方式进行调用方法。</p><p>栈帧又分为几点：局部变量表、操作数栈、动态连接、方法返回地址等。</p><h2 id="7-堆"><a href="#7-堆" class="headerlink" title="7. 堆"></a>7. 堆</h2><p>主要存放对象实例。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 虚拟机 Jvm 堆内存分配</title>
    <link href="/blogs/2021/06/04/jvm/jvm1.0/"/>
    <url>/blogs/2021/06/04/jvm/jvm1.0/</url>
    
    <content type="html"><![CDATA[<p class="note note-info">堆内存是 JVM 一块重点的区域,我们所说的 JVM 调优也是这一块。</p><h2 id="1-内存分配"><a href="#1-内存分配" class="headerlink" title="1. 内存分配"></a>1. 内存分配</h2><p>在jdk1.7版本中堆内存被划分为三块：新生代、老年代、持久代。<br><img src="/essay/jvm1.0/img_1.png"></p><p>新生代又主要分为：Eden区（伊甸园）、From Survivor区（幸存区0）、To Survivor区（幸存区1）。JVM默认分配空间为 8:1:1。也就是说Eden的空间分配是最大的。<br><img src="/essay/jvm1.0/img_2.png"></p><h2 id="2-对象分配"><a href="#2-对象分配" class="headerlink" title="2. 对象分配"></a>2. 对象分配</h2><p class="note note-info">我们新创建的对象实例首先会放在 新生代的Eden区（伊甸园）。</p><h3 id="1-1-大对象分配"><a href="#1-1-大对象分配" class="headerlink" title="1.1. 大对象分配"></a>1.1. 大对象分配</h3><p>我们也可以设置JVM参数将新创建对象实例放入老年代中。</p><p>虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。</p><p>其目是为让新生代更好的运行。新生代采用的是复制算法下面会为大家讲述。</p><h3 id="1-2-新生代的运行"><a href="#1-2-新生代的运行" class="headerlink" title="1.2. 新生代的运行"></a>1.2. 新生代的运行</h3><p class="note note-info">新创建的对象会放在Eden区（伊甸园），当Eden空间满了的时候会进行GC操作。称之为Minor GC。</p><p>1.Eden区（伊甸园）满了进行Minor GC进行空间清理死亡的对象。将Eden区（伊甸园）清理完后的对象复制到 S0（幸存者），S1为空。</p><p>2.当下一次 Eden 满了触发Minor GC时,清理Eden空间死亡对象，将存活对象复制到S1（幸存区)。同时，将清理S0（幸存区）空间死亡对象，将存活对象复制到S1。清空S0</p><p>Survivor区总有一个（幸存区）为空。</p><p>jvm给每个对象都分配了一个年龄，每次Minor GC对象就会+1。</p><p>jvm -XX:MaxTenuringThreshold 默认为15,也就是说对象年龄大于15就会进入老年代。我们也可以设置这个参数。</p><p class="note note-danger">注意：当发生Minor GC的时候，发现Survivor空间不足，部分对象无法复制到Survivor区，虚拟机通过分配担保机制将这些对象提前转移到老年代。有兴趣可以看看这个担保机制。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 操作使用命令</title>
    <link href="/blogs/2021/06/04/docker/docker-ming-ling/"/>
    <url>/blogs/2021/06/04/docker/docker-ming-ling/</url>
    
    <content type="html"><![CDATA[<p>简单说说 <span class="label label-primary">Docker</span> 优点,能简化我们配置环境的问题,假设现在在现有 <span class="label label-primary">linux</span> 服务器上安装一个需要依赖多个包的软件,需要在多台 <span class="label label-primary">linux</span> 安装同一软件时,将上一台机器的环境复制过来,简化安装。</p><h2 id="1-Docker-的主要用途"><a href="#1-Docker-的主要用途" class="headerlink" title="1. Docker 的主要用途"></a>1. Docker 的主要用途</h2><ul>    <li>提供一次性的环境。比如,本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。<span class="label label-warning">比如,在我机器可以运行,在你机器运行报错,这样问题的出现。</span>     </li>    <li>提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。    </li>    <li>组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。    </li></ul><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1. 安装"></a>1.1. 安装</h3><div class="hljs code-wrapper"><pre><code class="hljs Python">yum -y install docker-io</code></pre></div><h3 id="1-2-删除"><a href="#1-2-删除" class="headerlink" title="1.2. 删除"></a>1.2. 删除</h3><div class="hljs code-wrapper"><pre><code class="hljs Python">yum remove docker</code></pre></div><h3 id="1-3-删除"><a href="#1-3-删除" class="headerlink" title="1.3. 删除"></a>1.3. 删除</h3><div class="hljs code-wrapper"><pre><code class="hljs Python">service docker start</code></pre></div><h3 id="1-4-停用"><a href="#1-4-停用" class="headerlink" title="1.4. 停用"></a>1.4. 停用</h3><div class="hljs code-wrapper"><pre><code class="hljs Python">service docker stop</code></pre></div><h3 id="1-5-重启"><a href="#1-5-重启" class="headerlink" title="1.5. 重启"></a>1.5. 重启</h3><div class="hljs code-wrapper"><pre><code class="hljs Python">service docker restart</code></pre></div><h2 id="2-镜像加速"><a href="#2-镜像加速" class="headerlink" title="2. 镜像加速"></a>2. 镜像加速</h2><p>修改 <span class="label label-primary">/etc/docker/daemon.json</span> 文件并添加上 registry-mirrors 键值</p><div class="hljs code-wrapper"><pre><code class="hljs Python">&#123;  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;http://hub-mirror.c.163.com&quot;</span>]&#125;</code></pre></div><p class="note note-info">然后重新启动下docker服务: service docker restart</p><h2 id="3-Docker-操作容器命令"><a href="#3-Docker-操作容器命令" class="headerlink" title="3. Docker 操作容器命令"></a>3. Docker 操作容器命令</h2><div class="hljs code-wrapper"><pre><code class="hljs Python">docker pull <span class="hljs-built_in">id</span>/name     拉取镜像docker ps <span class="hljs-built_in">id</span>/name       查看运行容器docker ps -a <span class="hljs-built_in">id</span>/name    查看所有容器的状态docker start/stop <span class="hljs-built_in">id</span>/name    启动/停止某个容器docker attach <span class="hljs-built_in">id</span>        进入某个容器(使用exit退出后容器也跟着停止运行)docker <span class="hljs-built_in">exec</span> -it <span class="hljs-built_in">id</span>  bash 或 /<span class="hljs-built_in">bin</span>/sh  启动一个伪终端以交互式的方式进入某个容器(使用exit退出后容器不停止运行)docker images 查看本地镜像docker rm <span class="hljs-built_in">id</span>/name 删除某个容器</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud Eureka 服务治理</title>
    <link href="/blogs/2021/06/04/java/SpringCloud-Eureka/"/>
    <url>/blogs/2021/06/04/java/SpringCloud-Eureka/</url>
    
    <content type="html"><![CDATA[<h2 id="1-服务提供者"><a href="#1-服务提供者" class="headerlink" title="1. 服务提供者"></a>1. 服务提供者</h2><h3 id="1-1-服务注册"><a href="#1-1-服务注册" class="headerlink" title="1.1. 服务注册"></a>1.1. 服务注册</h3><span class="label label-primary">Eureka clien</span>  端在注册在启动中会先向 <span class="label label-primary">Eureka Service</span>  端发送一个REST请求,请求里包括当前服务名称以及自身的一些元数据。Service 端在收到请求之后会将这些数据存储在一个双层 Map 中。<p class="note note-secondary">（第一层存储的是服务名称,第二层存储的是服务本身实例。）</p><h3 id="1-2-服务同步"><a href="#1-2-服务同步" class="headerlink" title="1.2. 服务同步"></a>1.2. 服务同步</h3><p>现在 <span class="label label-primary">Eureka Service</span> 端有两台,它们相互注册。当 client 在任意一台Service上注册,Service收到请求后会转发请求给集群中心的其他Service。从而实现注册中心的服务同步,答到访问集群中任意节点都能获取当前服务。</p><h3 id="1-3-服务续约"><a href="#1-3-服务续约" class="headerlink" title="1.3. 服务续约"></a>1.3. 服务续约</h3><p>Eureka client 端在注册后会维护一个心跳机制,每30秒来告诉 Eureka Service 当前服务还活着,防治 Eureka Service 剔除当前实例。</p><h2 id="2-服务消费者"><a href="#2-服务消费者" class="headerlink" title="2. 服务消费者"></a>2. 服务消费者</h2><h3 id="2-1-服务获取"><a href="#2-1-服务获取" class="headerlink" title="2.1. 服务获取"></a>2.1. 服务获取</h3><p>Eureka client 端向 Eureka Service 发送一个REST请求获取一份只读的服务器清单,在只读清单中获取具体服务。Eureka Service 为性能考虑每30秒会更新一份只读清单。（如果是负载均衡的默认使用的是轮询方式）</p><h3 id="2-2-服务调用"><a href="#2-2-服务调用" class="headerlink" title="2.2. 服务调用"></a>2.2. 服务调用</h3><p>Eureka client 在获取清单后根据服务名称去获取某个服务,如果服务是负载均衡的。将会默认使用轮询方式调用服务（也这里可以设置为随机调用）</p><h3 id="2-3-服务下线"><a href="#2-3-服务下线" class="headerlink" title="2.3. 服务下线"></a>2.3. 服务下线</h3><p>Eureka client 在关闭或重启时,会发送一个REST请求告诉Eureka Service我要下线了。从而让 Eureka Service 剔除当前实例</p><h2 id="3-注册中心"><a href="#3-注册中心" class="headerlink" title="3. 注册中心"></a>3. 注册中心</h2><h3 id="3-1-失效剔除"><a href="#3-1-失效剔除" class="headerlink" title="3.1. 失效剔除"></a>3.1. 失效剔除</h3><p>某一些服务可能因为网络原因,内存不够,宕机等问题导致服务不能正常的服务下线。Eureka Service 在创建时间会维护一个定时器,定时器每60秒执行一次获取清单里默认90秒没有续约的服务进行剔除。</p><h3 id="3-2-自我保护"><a href="#3-2-自我保护" class="headerlink" title="3.2. 自我保护"></a>3.2. 自我保护</h3><p>一般在调试项目时我们会发现下面这个错误:</p><p class="note note-danger">"EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE."</p><p class="note note-info">Eureka client 维护一个心跳机制30每秒去续约。Eureka Server 在运行期间，会去统计心跳失败比例在 15 分钟之内是否低于 85%，如果低于 85%，Eureka Server 会将这些实例保护起来，让这些实例不会过期，但是在保护期内如果服务刚好这个服务提供者非正常下线了，此时服务消费者就会拿到一个无效的服务实例，此时会调用失败，对于这个问题需要服务消费者端要有一些容错机制，如重试，断路器等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>Eureka</tag>
      
      <tag>服务治理</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
